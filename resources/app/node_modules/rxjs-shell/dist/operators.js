"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.execWithStdin = exports.throwIfStderr = exports.throwIfStdout = exports.throwIf = exports.trim = void 0;
const rxjs_1 = require("rxjs");
const exec_1 = require("./exec");
const models_1 = require("./models");
const util_1 = require("./util");
function trim(encoding = 'utf8') {
    return function trimImplementation(source) {
        return rxjs_1.Observable.create((subscriber) => {
            const subscription = source.subscribe(value => {
                if ((0, models_1.isSpawnChunk)(value)) {
                    subscriber.next({
                        type: value.type,
                        chunk: Buffer.from(String(value.chunk).trim(), encoding),
                    });
                }
                else if ((0, models_1.isExecOutput)(value)) {
                    subscriber.next({
                        stdout: Buffer.isBuffer(value.stdout)
                            ? Buffer.from(value.stdout.toString(encoding).trim())
                            : value.stdout.trim(),
                        stderr: Buffer.isBuffer(value.stderr)
                            ? Buffer.from(value.stderr.toString(encoding).trim())
                            : value.stderr.trim(),
                    });
                }
                else {
                    subscriber.next(value);
                }
            }, err => subscriber.error(err), () => subscriber.complete());
            return subscription;
        });
    };
}
exports.trim = trim;
var TargetOutput;
(function (TargetOutput) {
    TargetOutput[TargetOutput["STDOUT"] = 1] = "STDOUT";
    TargetOutput[TargetOutput["STDERR"] = 2] = "STDERR";
})(TargetOutput || (TargetOutput = {}));
function throwIfNeeded(subscriber, value, pattern, targetOutput) {
    if ((0, models_1.isSpawnChunk)(value)) {
        if (targetOutput & TargetOutput.STDOUT &&
            'stdout' === value.type &&
            pattern.test(value.chunk.toString())) {
            subscriber.error(new util_1.ShellError(`throwIf: stdout is matching ${pattern}`, undefined, value.chunk));
            return;
        }
        if (targetOutput & TargetOutput.STDERR &&
            'stderr' === value.type &&
            pattern.test(value.chunk.toString())) {
            subscriber.error(new util_1.ShellError(`throwIf: stderr is matching ${pattern}`, undefined, undefined, value.chunk));
            return;
        }
        subscriber.next(value);
        return;
    }
    else if ((0, models_1.isExecOutput)(value)) {
        if (targetOutput & TargetOutput.STDOUT &&
            pattern.test(value.stdout.toString())) {
            subscriber.error(new util_1.ShellError(`throwIf: stdout is matching ${pattern}`, undefined, value.stdout));
            return;
        }
        if (targetOutput & TargetOutput.STDERR &&
            pattern.test(value.stderr.toString())) {
            subscriber.error(new util_1.ShellError(`throwIf: stderr is matching ${pattern}`, undefined, undefined, value.stderr));
            return;
        }
        subscriber.next(value);
        return;
    }
    subscriber.next(value);
}
function throwIf(pattern) {
    const _pattern = 'string' === typeof pattern ? new RegExp(pattern) : pattern;
    return function throwIfImplementation(source) {
        return rxjs_1.Observable.create((subscriber) => {
            const subscription = source.subscribe(value => throwIfNeeded(subscriber, value, _pattern, TargetOutput.STDOUT | TargetOutput.STDERR), err => subscriber.error(err), () => subscriber.complete());
            return subscription;
        });
    };
}
exports.throwIf = throwIf;
function throwIfStdout(pattern) {
    const _pattern = 'string' === typeof pattern ? new RegExp(pattern) : pattern;
    return function throwIfStdoutImplementation(source) {
        return rxjs_1.Observable.create((subscriber) => {
            const subscription = source.subscribe(value => throwIfNeeded(subscriber, value, _pattern, TargetOutput.STDOUT), err => subscriber.error(err), () => subscriber.complete());
            return subscription;
        });
    };
}
exports.throwIfStdout = throwIfStdout;
function throwIfStderr(pattern) {
    const _pattern = 'string' === typeof pattern ? new RegExp(pattern) : pattern;
    return function throwIfStderrImplementation(source) {
        return rxjs_1.Observable.create((subscriber) => {
            const subscription = source.subscribe(value => throwIfNeeded(subscriber, value, _pattern, TargetOutput.STDERR), err => subscriber.error(err), () => subscriber.complete());
            return subscription;
        });
    };
}
exports.throwIfStderr = throwIfStderr;
function execWithStdin(command, options) {
    return function execWithStdinImplementation(source) {
        return source.pipe((0, rxjs_1.mergeMap)(input => (0, exec_1.exec)(command, options, proc => {
            var _a, _b;
            (_a = proc.stdin) === null || _a === void 0 ? void 0 : _a.write(input);
            (_b = proc.stdin) === null || _b === void 0 ? void 0 : _b.end();
        })));
    };
}
exports.execWithStdin = execWithStdin;
//# sourceMappingURL=operators.js.map