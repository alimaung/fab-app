"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.listenTerminating = exports.ShellError = exports.spawnEnd = exports.killProc = void 0;
const rxjs_1 = require("rxjs");
const tree_kill_1 = __importDefault(require("tree-kill"));
function killProc(proc) {
    if (proc.stdout) {
        proc.stdout.removeAllListeners();
    }
    if (proc.stderr) {
        proc.stderr.removeAllListeners();
    }
    proc.removeAllListeners();
    if (typeof proc.pid === 'number') {
        (0, tree_kill_1.default)(proc.pid, 'SIGKILL');
        return;
    }
    proc.kill('SIGKILL');
}
exports.killProc = killProc;
function spawnEnd(spawnObservable) {
    const sbj = new rxjs_1.Subject();
    const stdouts = [];
    const stderrs = [];
    spawnObservable.subscribe(chunk => {
        if (chunk.type === 'stdout') {
            stdouts.push(chunk.chunk);
        }
        else {
            stderrs.push(chunk.chunk);
        }
    }, err => sbj.error(err), () => sbj.next({ stdout: Buffer.concat(stdouts), stderr: Buffer.concat(stderrs) }));
    return sbj;
}
exports.spawnEnd = spawnEnd;
class ShellError extends Error {
    constructor(message, originError, stdout, stderr) {
        super(message);
        this.message = message;
        this.originError = originError;
        this.stdout = stdout;
        this.stderr = stderr;
    }
    toAnnotatedString() {
        let msg = `
-----* MESSAGE *-----
${this.message}
---------------------`;
        if (this.originError) {
            msg += `
-----* ERROR *-------
${JSON.stringify(this.originError, undefined, 2)}
---------------------`;
        }
        if (this.stdout) {
            msg += `
-----* STDOUT *------
${this.stdout.toString('utf8')}
---------------------`;
        }
        if (this.stderr) {
            msg += `
-----* STDERR *------
${this.stderr.toString('utf8')}
---------------------`;
        }
        return msg;
    }
}
exports.ShellError = ShellError;
function listenTerminating(fn, events = ['SIGINT', 'SIGBREAK']) {
    events.forEach(name => process.on(name, fn));
    process.on('exit', fn);
    return () => {
        events.forEach(name => process.off(name, fn));
        process.off('exit', fn);
    };
}
exports.listenTerminating = listenTerminating;
//# sourceMappingURL=util.js.map